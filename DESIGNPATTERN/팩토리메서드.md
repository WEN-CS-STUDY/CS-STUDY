템플릿 메서드 패턴은 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.

변하지 않는 기능은 상위 클래스에 만들어두고, 자주 변경되며 확장할 기능을 하위 클래스에 만들어 둘을 유연하게 선택해 사용할 수 있도록 한다.

코드 예시

```jsx
**class FileProcessor {
    private String path; // 생성자로 부터 파일경로를 받아와 저장

    public FileProcessor(String path) {
        this.path = path;
    }

    public int process() {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;

            // 파일에 있는 각 라인에 있는 숫자값들을 모두 덧셈
            while ((line = reader.readLine()) != null) {
                result += Integer.parseInt(line);
            }
            return result;

        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }
}

class Client {
    public static void main(String[] args) {
        // 파일경로 설정
        FileProcessor fileProcessor = new FileProcessor("number.txt");

        // 덧셈한 결과값 얻기
        int result = fileProcessor.process();
        System.out.println(result);
    }
}**
```

```jsx
class MultiplyFileProcessor {
    private String path;

    public MultiplyFileProcessor(String path) {
        this.path = path;
    }

    public int process() {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;

            // 파일에 있는 각 라인에 있는 숫자값들을 모두 곱셈
            while ((line = reader.readLine()) != null) {
                result *= Integer.parseInt(line); // 이 부분만 곱셈으로 바꿔준다.
            }
            return result;
            
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }
}
```

위 코드르 사용중 아래 곱샘을 추가한다면 어떻게 추가할까

공통부분을 상위 클래스로 사용하고, 다른 부분을 하위 클래스에서 확장하여 사용한다.

```jsx
abstract class FileProcessor {
    private String path; // 생성자로 부터 파일경로를 받아와 저장

    public FileProcessor(String path) {
        this.path = path;
    }

    // 템플릿 메소드 (오버라이딩 못하게 final 처리)
    public final int process() {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = getResult();
            String line = null;

            while ((line = reader.readLine()) != null) {
                result = caculate(result, Integer.parseInt(line));
            }
            return result;

        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }

    protected abstract int caculate(int result, int number);
    protected abstract int getResult();
}
```

이를 공통부분으로 상위클래스 (추상클래스)로 사용.

다른 부분인 caculate 와 getResult 를 추상메서드로 정의 자식 클래스에서 구현한다.

```jsx
// 더하기 연산 수행
class PlusFileProcessor extends FileProcessor{

    public PlusFileProcessor(String path) {
        super(path);
    }

    @Override
    protected int caculate(int result, int number) {
        return result += number;
    }
    
    @Override
    protected int getResult() {
        return 0;
    }
}

// 곱셈 연산 수행
class MultiplyFileProcessor extends FileProcessor{

    public MultiplyFileProcessor(String path) {
        super(path);
    }

    @Override
    protected int caculate(int result, int number) {
        return result *= number;
    }
    
    @Override
    protected int getResult() {
        return 1; // 곱셈은 초깃값이 0이면 결과도 멱등하니까
    }
}
```

```jsx
class Client {
    public static void main(String[] args) {
        PlusFileProcessor plusFileProcessor = new PlusFileProcessor("numbers.txt");
        int result1 = plusFileProcessor.process();
        System.out.println(result1); // 15

        MultiplyFileProcessor multiplyFileProcessor = new MultiplyFileProcessor("numbers.txt");
        int result2 = multiplyFileProcessor.process();
        System.out.println(result2); // 120
    }
}
```

이를 통해 동적으로 유용하게 로직이 정해진다.

패턴 장점

- 상위 추상클래스로 로직을 공통화 하여 코드의 중복을 줄일 수 있다.
- 마찬가지 이유로 관리가 용이해진다.

패턴 단점

- 알고리즘의 제공된 골격에 의하여 유연성이 제한될 수 있다. (어뎁터와는 다르게 공통부분을 사용하기 때문)
- 알고리즘 구조가 복잡할수록 형태를 유지하기 어려워진다.
- 로직에 변화가 생겨 상위 클래스를 수정할 때, 모든 서브 클래스의 수정이 필요 할 수도 있다.