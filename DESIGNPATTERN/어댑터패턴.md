어댑터 패턴

해외에 나갈때 110V 가전제품을 사용하기 위하여 사용하는 것이 어댑터

어댑터 패턴은 이러한 것 처럼 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해줃록 변환시켜주는 클래스.

어댑터 패턴 구조는 크게 두가지로 나뉜다.

객체 어댑터

- 합성(Composition)된 맴버에게 위임을 이용한 어댑터 패턴
- 자기가 해야 할 일을 클래스 맴버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다.
- 합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다.
- 그러나 Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다

예시를 보면

A 엔진을 사용하던 중 B 엔진의 성능이 좋아 사용.

but B 에는 A 에서 사용하던 메소드가 없음.

```jsx
// 기존의 인터페이스는 손대지 않는다
interface ISortEngine {
    void setList(); // 정렬할 리스트
    void sort(); // 정렬 알고리즘
    void reverseSort(); // 역순 정렬 알고리즘
    void printSortListPretty(); // 정렬된 리스트를 예쁘게 출력
}

class A_SortEngine implements ISortEngine {
    public void setList() {}
    public void sort() {}
    public void reverseSort() {}
    public void printSortListPretty() {}
}

class B_SortEngine {
    public void setList() {} // 정렬할 리스트
    public void sorting(boolean isReverse) {} // 정렬 / 역순 정렬 알고리즘 (파라미터로 순서 결정)
}
```

```jsx
// 객체 어댑터를 구성한다.
class SortEngineAdaptor implements ISortEngine {
    // (두 엔진을 composition 하여 이용)
    A_SortEngine Aengine;
    B_SortEngine Bengine;

    SortEngineAdaptor(A_SortEngine Aengine, B_SortEngine Bengine) {
        this.Aengine = Aengine;
        this.Bengine = Bengine;
    }

    @Override
    public void setList() {
        Bengine.setList();
    }

    @Override
    public void sort() {
        Bengine.sorting(false); // 메서드 시그니처가 달라고 위임을 통해 호환 작업
    }

    @Override
    public void reverseSort() {
        Bengine.sorting(true); // 메서드 시그니처가 달라고 위임을 통해 호환 작업
    }

    @Override
    public void printSortListPretty() {
        Aengine.printSortListPretty(); // B 엔진에 없는 기능을 A 엔진으로 실행
    }
}
```

```jsx
// Client 역할을 하는 클래스 : Sort 엔진 객체를 받아 실행
class SortingMachine {
    ISortEngine engine;

    void setEngine(ISortEngine engine) { this.engine = engine; }

    void sortingRun() {
        engine.setList();

        engine.sort();
        engine.printSortListPretty();

        engine.reverseSort();
        engine.printSortListPretty();
    }

    public static void main(String[] args) {
        // 클라이언트의 머신에 원본 엔진 대신 어댑터를 할당한다.
        ISortEngine adaptor = new SortEngineAdaptor(new A_SortEngine(), new B_SortEngine());
        SortingMachine machine = new SortingMachine();
        machine.setEngine(adaptor);

        machine.sortingRun();
    }
}
```

클래스 어댑터

- 클래스 상속을 이용한 어댑터 패턴
- Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.
- 상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 전반적으로 권장하지는 않는 방법이다.

예시를 보면

```jsx
// 클래스 어댑터를 구성한다.
class SortEngineAdaptor extends B_SortEngine implements ISortEngine {

    @Override
    public void setList() {
        super.setList();
    }

    @Override
    public void sort() {
        sorting(false);
    }

    @Override
    public void reverseSort() {
        sorting(true);
    }

    @Override
    public void printSortListPretty() {
        // A_SortEngine 클래스의 원본 printSortListPretty 메서드의 알고리즘 로직을 그대로 복붙 및 구현
    }
}
```

```jsx
// Client 역할을 하는 클래스 : Sort 엔진 객체를 받아 실행
class SortingMachine {
    ISortEngine engine;

    void setEngine(ISortEngine engine) { this.engine = engine; }

    void sortingRun() {
        engine.setList();

        engine.sort();
        engine.printSortListPretty();

        engine.reverseSort();
        engine.printSortListPretty();
    }

    public static void main(String[] args) {
        // 클라이언트의 머신에 원본 엔진 대신 어댑터를 할당한다.
        ISortEngine adaptor = new SortEngineAdaptor();
        SortingMachine machine = new SortingMachine();
        machine.setEngine(adaptor);

        machine.sortingRun();
    }
}
```

자바에서는 단일 상속만 가능하기 때문에 한계가 명확하다.