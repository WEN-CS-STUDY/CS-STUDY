[[운영체제] CPU 스케줄링](https://rob-coding.tistory.com/31)

### CPU 스케줄링

- 준비큐에 있는 프로세스들중 어떤 프로세스를 CPU에 할당할지 정하는 기법
- 작업의 형평성과 효율성을 결정하는 중요한 요소

### 스케줄링의 목적

1. 공평성
2. 효율성
3. 안정성
4. 반응 시간 보장
5. 무한 연기 방지

### 프로세스의 우선순위

1. 커널 프로세스 vs 일반 프로세스
    1. 커널 프로세스가 중요한 작업을 많이 하므로 더 높다.
2. CPU 집중 프로세스 vs 입출력 집중 프로세스
    1. 입출력 집중 프로세스가 더 높다. 입출력 집중 프로세스를 CPU에 할당하다가 입출력 요구가 발생하면 대기 상태로 가기 때문에 이 때 다른 프로세스가 CPU를 사용할 수 있기 때문임.
3. 전면 프로세스 vs 후면 프로세스
    1. 전면 프로세스의 우선순위가 더 높다. (전면 프로세스는 사용자와 상호작용 해야하는 프로세스, 후면은 단순히 컴퓨터 내부에서만 실행되는 프로세스)
    

### 프로세스 다중 큐

![image.png](/ASSET/CPU스케줄링1.png)

- CPU에 할당하려면 매번 PCB에 있는 우선순위를 다 뒤져야 한다. → 비효율
- 따라서 우선순위 별로 큐를 만들어서 관리하면 편하다.

### 대기 상태 다중 큐 vs 준비 상태 다중 큐

- 준비 상태는 한번에 하나의 프로세스만 CPU에 할당
- 대기 상태는 여러개를 한번에 꺼내 준비 상태로 보낼 수 있음.

![image.png](/ASSET/CPU스케줄링2.png)

### 비 선점형 스케줄링

1. FCFS 스케줄링
    1. 준비 상태에 먼저 들어온 것 부터 먼저 처리함
    2. 처리 시간이 긴 프로세스가 들어오면 뒤 프로세스들은 하염없이 기다릴 수 만 있는 문제가 있음.
    3. 이를 해결하기 위해 SJF 가나옴
2. SJF 스케줄링
    - 작업 시간이 짧은 녀석들부터 먼저 처리함
    - 현대 프로세스들은 실행 시간을 정확히 측정할 수 없어 도입하기 어려움
    - 또한 처리 시간이 긴 프로세스는 전혀 실행되지 않는 기아 현상이 나타날 수 있음.
    

### 선점형 스케줄링

1. RR 스케줄링
    1. 일정한 시간 동안 작업을 하고, 작업이 끝나지 못하면 준비 큐 맨 뒤로 가서 작업을 기다리는 방법
    2. 일정한 시간을 너무 길게하면 FCFS랑 똑같아짐
    3. 일정한 시간을 너무 짧게하면 문맥 교환 오버헤드로 인한 문제가 발생할 수 있음.
    4. 따라서 적절한 시간을 정하는 것이 중요함. 
2. SRT 스케줄링
    1. SJF + RR 스케줄링임. 남은 처리 시간이 최소인 것부터 실행함. 
    2. SJF와 마찬가지로 실행 시간을 측정할 수 없고, 기아 현상으로 인해 잘 사용하지 않는다. 
3. 다단계 큐 스케줄링
    
    ![image.png](/ASSET/CPU스케줄링3.png)
    
    - 운영체제가 정해주는 우선 순위에 따라 특정한 큐에 배정된다.
    - 그 큐 안에서는 RR 방식 사용.
    - 상단 우선순위에 있는 모든 작업이 끝나야 다음 우선순위 큐가 실행된다.
4. 다단계 피드백 큐 스케줄링

![image.png](/ASSET/CPU스케줄링4.png)

- CPU 작업이 끝나면 기존 우선순위보다 한 단계 아래로 들어간다. (단 커널같은 중요한 작업은 일반으로 들어가지 않는다.)
- 우선순위가 낮을 수록 RR의 타임 슬라이스 크기가 커진다. (어렵게 해서 얻었으니 더 많이 사용)
- 변동 우선순위 방식 사용