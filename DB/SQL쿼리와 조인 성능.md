쿼리의 처리 흐름

1. sql 이 작성되고 실행된다.
2. 파서(Parser)가 작성된 문법검사와 구문 분석을 실시한다.
3. 옵티마이저가 실행 계획을 생성하고 비용을 평가, 이 결과를 토대로 실행계획을 결정한다.
4. 이 계획을 통해서 sql 실행 엔진이 데이터 처리.

sql 의 성능을 책임지는 부분은 옵티마이저.

옵티마이저 : sql 을 실행할때 내부적으로 이 sql 을 빠르고 효율적으로 처리를 하기 위하여 이 sql 의 실행계획을 짜는 것이 옵티마이저 이다.

- 규칙기반 옵티마이저(Rule Based Optimizer)

실행계획을 세울때 특정한 규칙에 따라 세우는 방식. 규칙은 여러개가 있고, 이 규칙마다 우선 순위가 존재한다.

| 1 | ROWID를 사용한 단일 행인 경우 |
| --- | --- |
| 2 | 클러스터 조인에 의한 단일 행인 경우 |
| 3 | 유일하거나 기본키(Primary Key)를 가진 해시 클러스터 키에 의한 단일 행인 경우 |
| 4 | 유일하거나 기본키(Primary Key)에 의한 단일 행인 경우 |
| 5 | 클러스터 조인인 경우 |
| 6 | 해시 클러스터 조인인 경우 |
| 7 | 인덱스 클러스터 키인 경우 |
| 8 | 복합 칼럼 인덱스인 경우 |
| 9 | 단일 칼럼 인덱스인 경우 |
| 10 | 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우( ex) BETWEEN , LIKE 연산자를 이용시) |
| 11 | 인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우(ex) >, >=, =, < =, <  연산자 사용시) |
| 12 | 정렬-병합(Sort-Merge) 조인인 경우 |
| 13 | 인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우 |
| 14 | 인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우 |
| 15 | 전체 테이블을 스캔(FULL TABLE SCAN)하는 경우 |

무조건 규칙대로 실행하는것이 좋은 것은 아니다.

현재는 보통 비용기반 옵티마이저를 사용한다.

- 비용기반 옵티마이저(Cost Based Optimizer)

인덱스나 DBMS 제약 설정등 여러가지 요인을 통해 여러가지의 실행계획을 비교하여 가장 비용이 작은 실행 계획을 사용하는 방식이다.

우리가 따로 연산의 순서를 정해줄 수 있지만, 결국 큰 데이터에 대한 연산은 옵티마이저에게 맡기는 것이 가장 효율적일 가능성이 높다.

결국 조인에 대한 연산도 옵티마이저에서 가장빠른 실행계획을 만들어준다.

mysql 에서는 Nested Loops Join 을 사용하여 조인연산을 한다.

![image.png](/ASSET/조인성능.png)

왼쪽 테이블의 각 레코드마다 조인되는 테이블의 모든 레코드를 탐색하여 조인연산에 만족하는 레코드를 찾는 것입니다.

이 경우에는 Table A, Table B 의 결합 대상 레코드 수를 R(A), R(B) 라고 한다면 접근되는 레코드 수는 R(A) * R(B) 가 됩니다.

그럼 성능을 높이기 위해서는 어떤 방법이 있을까?

먼저 조인이 되는 Table B 의 조인의 조건이 되는 컬럼에 Index 가 존재한다면 Full scan 이 아닌 Index 파일을 검색하여 더 빠르게 조인조건을 찾을 수 있습니다.

그리고 만약 두 테이블 모두 인덱스가 존재한다면, 두 테이블 중에 A 테이블의 레코드 수가 적으니 기준이 되는 테이블이 된다면 더 적은 연산을 할 것입니다.

이러한 기준이되는 왼쪽 테이블을 구동테이블(Driving Table) 이라고 하는데 이는 어떻게 결정을 할까요?

이는 우리가 아닌 옵티마이저가 결정을 하게 됩니다.

위에서 말한 index 의 유무, 테이블 레코드의 수, 등 여러가지를 고려하여 구동테이블을 결정을 하게 됩니다.

만약 Outer Join 을 실행하는 경우는 어떻게 될까?

Outer Join 은 Inner Join 과 다르게 순서가 중요하기 때문에 구동테이블이 정해져 있습니다.

여기서 우리가 실행을 제어할 수 있는 방법이 존재합니다.

DBMS 마다 다르지만 힌트 라는 개념을 통해 실행계획을 제어할 수 있습니다.

힌트란 쉽게 설명하면 쿼리 옵티마이저가 사용할 특별한 지시사항을 의미합니다. 예를들어 인덱스를 사용하도록 지시하거나, 테이블의 조인 순서를 제안하는 등의 방식이 있습니다.

하지만 모든 테이블은 데이터의 양의 변화가 존재하기 때문에 이런 유동적인 환경에서 하나의 지시사항을 정해놓는 경우 성능의 하락으로 이어질 수 있기 때문에 조심해야 합니다.